import{B as _n,V as z,j as G,bm as bt,aP as ft,L as un,bn as zn,a as j,x as Pt,u as _t,s as Dn,n as Fn,r as pn}from"./ExtendedTriangle-Chm2bbkR.js";const Pn=0,Rn=1,vn=2,Ri=0,vi=1,yn=2,It=1.25,xn=1,dt=6*4+4+4,Xt=65535,Nn=Math.pow(2,-24),jt=Symbol("SKIP_GENERATION");function Vn(i){return i.index?i.index.count:i.attributes.position.count}function ut(i){return Vn(i)/3}function $n(i,n=ArrayBuffer){return i>65535?new Uint32Array(new n(4*i)):new Uint16Array(new n(2*i))}function kn(i,n){if(!i.index){const t=i.attributes.position.count,e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=$n(t,e);i.setIndex(new _n(s,1));for(let c=0;c<t;c++)s[c]=c}}function Mn(i,n){const t=ut(i),e=n||i.drawRange,s=e.start/3,c=(e.start+e.count)/3,r=Math.max(0,s),l=Math.min(t,c)-r;return[{offset:Math.floor(r),count:Math.floor(l)}]}function Sn(i,n){if(!i.groups||!i.groups.length)return Mn(i,n);const t=[],e=new Set,s=n||i.drawRange,c=s.start/3,r=(s.start+s.count)/3;for(const o of i.groups){const u=o.start/3,f=(o.start+o.count)/3;e.add(Math.max(c,u)),e.add(Math.min(r,f))}const l=Array.from(e.values()).sort((o,u)=>o-u);for(let o=0;o<l.length-1;o++){const u=l[o],f=l[o+1];t.push({offset:Math.floor(u),count:Math.floor(f-u)})}return t}function qn(i,n){const t=ut(i),e=Sn(i,n).sort((r,l)=>r.offset-l.offset),s=e[e.length-1];s.count=Math.min(t-s.offset,s.count);let c=0;return e.forEach(({count:r})=>c+=r),t!==c}function Yt(i,n,t,e,s){let c=1/0,r=1/0,l=1/0,o=-1/0,u=-1/0,f=-1/0,p=1/0,a=1/0,y=1/0,d=-1/0,b=-1/0,g=-1/0;for(let h=n*6,x=(n+t)*6;h<x;h+=6){const m=i[h+0],w=i[h+1],A=m-w,T=m+w;A<c&&(c=A),T>o&&(o=T),m<p&&(p=m),m>d&&(d=m);const B=i[h+2],P=i[h+3],S=B-P,M=B+P;S<r&&(r=S),M>u&&(u=M),B<a&&(a=B),B>b&&(b=B);const U=i[h+4],_=i[h+5],C=U-_,L=U+_;C<l&&(l=C),L>f&&(f=L),U<y&&(y=U),U>g&&(g=U)}e[0]=c,e[1]=r,e[2]=l,e[3]=o,e[4]=u,e[5]=f,s[0]=p,s[1]=a,s[2]=y,s[3]=d,s[4]=b,s[5]=g}function Xn(i,n=null,t=null,e=null){const s=i.attributes.position,c=i.index?i.index.array:null,r=ut(i),l=s.normalized;let o;n===null?(o=new Float32Array(r*6*4),t=0,e=r):(o=n,t=t||0,e=e||r);const u=s.array,f=s.offset||0;let p=3;s.isInterleavedBufferAttribute&&(p=s.data.stride);const a=["getX","getY","getZ"];for(let y=t;y<t+e;y++){const d=y*3,b=y*6;let g=d+0,h=d+1,x=d+2;c&&(g=c[g],h=c[h],x=c[x]),l||(g=g*p+f,h=h*p+f,x=x*p+f);for(let m=0;m<3;m++){let w,A,T;l?(w=s[a[m]](g),A=s[a[m]](h),T=s[a[m]](x)):(w=u[g+m],A=u[h+m],T=u[x+m]);let B=w;A<B&&(B=A),T<B&&(B=T);let P=w;A>P&&(P=A),T>P&&(P=T);const S=(P-B)/2,M=m*2;o[b+M+0]=B+S,o[b+M+1]=S+(Math.abs(B)+S)*Nn}}return o}function F(i,n,t){return t.min.x=n[i],t.min.y=n[i+1],t.min.z=n[i+2],t.max.x=n[i+3],t.max.y=n[i+4],t.max.z=n[i+5],t}function An(i){let n=-1,t=-1/0;for(let e=0;e<3;e++){const s=i[e+3]-i[e];s>t&&(t=s,n=e)}return n}function mn(i,n){n.set(i)}function hn(i,n,t){let e,s;for(let c=0;c<3;c++){const r=c+3;e=i[c],s=n[c],t[c]=e<s?e:s,e=i[r],s=n[r],t[r]=e>s?e:s}}function Mt(i,n,t){for(let e=0;e<3;e++){const s=n[i+2*e],c=n[i+2*e+1],r=s-c,l=s+c;r<t[e]&&(t[e]=r),l>t[e+3]&&(t[e+3]=l)}}function xt(i){const n=i[3]-i[0],t=i[4]-i[1],e=i[5]-i[2];return 2*(n*t+t*e+e*n)}const Y=32,Hn=(i,n)=>i.candidate-n.candidate,K=new Array(Y).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),St=new Float32Array(6);function In(i,n,t,e,s,c){let r=-1,l=0;if(c===Pn)r=An(n),r!==-1&&(l=(n[r]+n[r+3])/2);else if(c===Rn)r=An(i),r!==-1&&(l=jn(t,e,s,r));else if(c===vn){const o=xt(i);let u=It*s;const f=e*6,p=(e+s)*6;for(let a=0;a<3;a++){const y=n[a],g=(n[a+3]-y)/Y;if(s<Y/4){const h=[...K];h.length=s;let x=0;for(let w=f;w<p;w+=6,x++){const A=h[x];A.candidate=t[w+2*a],A.count=0;const{bounds:T,leftCacheBounds:B,rightCacheBounds:P}=A;for(let S=0;S<3;S++)P[S]=1/0,P[S+3]=-1/0,B[S]=1/0,B[S+3]=-1/0,T[S]=1/0,T[S+3]=-1/0;Mt(w,t,T)}h.sort(Hn);let m=s;for(let w=0;w<m;w++){const A=h[w];for(;w+1<m&&h[w+1].candidate===A.candidate;)h.splice(w+1,1),m--}for(let w=f;w<p;w+=6){const A=t[w+2*a];for(let T=0;T<m;T++){const B=h[T];A>=B.candidate?Mt(w,t,B.rightCacheBounds):(Mt(w,t,B.leftCacheBounds),B.count++)}}for(let w=0;w<m;w++){const A=h[w],T=A.count,B=s-A.count,P=A.leftCacheBounds,S=A.rightCacheBounds;let M=0;T!==0&&(M=xt(P)/o);let U=0;B!==0&&(U=xt(S)/o);const _=xn+It*(M*T+U*B);_<u&&(r=a,u=_,l=A.candidate)}}else{for(let m=0;m<Y;m++){const w=K[m];w.count=0,w.candidate=y+g+m*g;const A=w.bounds;for(let T=0;T<3;T++)A[T]=1/0,A[T+3]=-1/0}for(let m=f;m<p;m+=6){let T=~~((t[m+2*a]-y)/g);T>=Y&&(T=Y-1);const B=K[T];B.count++,Mt(m,t,B.bounds)}const h=K[Y-1];mn(h.bounds,h.rightCacheBounds);for(let m=Y-2;m>=0;m--){const w=K[m],A=K[m+1];hn(w.bounds,A.rightCacheBounds,w.rightCacheBounds)}let x=0;for(let m=0;m<Y-1;m++){const w=K[m],A=w.count,T=w.bounds,P=K[m+1].rightCacheBounds;A!==0&&(x===0?mn(T,St):hn(T,St,St)),x+=A;let S=0,M=0;x!==0&&(S=xt(St)/o);const U=s-x;U!==0&&(M=xt(P)/o);const _=xn+It*(S*x+M*U);_<u&&(r=a,u=_,l=w.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:l}}function jn(i,n,t,e){let s=0;for(let c=n,r=n+t;c<r;c++)s+=i[c*6+e*2];return s/t}class Zt{constructor(){this.boundingData=new Float32Array(6)}}function Yn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,u=c.axis*2;for(;;){for(;r<=l&&t[r*6+u]<o;)r++;for(;r<=l&&t[l*6+u]>=o;)l--;if(r<l){for(let f=0;f<3;f++){let p=n[r*3+f];n[r*3+f]=n[l*3+f],n[l*3+f]=p}for(let f=0;f<6;f++){let p=t[r*6+f];t[r*6+f]=t[l*6+f],t[l*6+f]=p}r++,l--}else return r}}function Zn(i,n,t,e,s,c){let r=e,l=e+s-1;const o=c.pos,u=c.axis*2;for(;;){for(;r<=l&&t[r*6+u]<o;)r++;for(;r<=l&&t[l*6+u]>=o;)l--;if(r<l){let f=i[r];i[r]=i[l],i[l]=f;for(let p=0;p<6;p++){let a=t[r*6+p];t[r*6+p]=t[l*6+p],t[l*6+p]=a}r++,l--}else return r}}function V(i,n){return n[i+15]===65535}function $(i,n){return n[i+6]}function k(i,n){return n[i+14]}function q(i){return i+8}function X(i,n){return n[i+6]}function Cn(i,n){return n[i+7]}function Ni(i){return i}let Un,Bt,kt,Ln;const Kn=Math.pow(2,32);function tn(i){return"count"in i?1:1+tn(i.left)+tn(i.right)}function Wn(i,n,t){return Un=new Float32Array(t),Bt=new Uint32Array(t),kt=new Uint16Array(t),Ln=new Uint8Array(t),nn(i,n)}function nn(i,n){const t=i/4,e=i/2,s="count"in n,c=n.boundingData;for(let r=0;r<6;r++)Un[t+r]=c[r];if(s)if(n.buffer){const r=n.buffer;Ln.set(new Uint8Array(r),i);for(let l=i,o=i+r.byteLength;l<o;l+=dt){const u=l/2;V(u,kt)||(Bt[l/4+6]+=t)}return i+r.byteLength}else{const r=n.offset,l=n.count;return Bt[t+6]=r,kt[e+14]=l,kt[e+15]=Xt,i+dt}else{const r=n.left,l=n.right,o=n.splitAxis;let u;if(u=nn(i+dt,r),u/4>Kn)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Bt[t+6]=u/4,u=nn(u,l),Bt[t+7]=o,u}}function Jn(i,n){const t=(i.index?i.index.count:i.attributes.position.count)/3,e=t>2**16,s=e?4:2,c=n?new SharedArrayBuffer(t*s):new ArrayBuffer(t*s),r=e?new Uint32Array(c):new Uint16Array(c);for(let l=0,o=r.length;l<o;l++)r[l]=l;return r}function Qn(i,n,t,e,s){const{maxDepth:c,verbose:r,maxLeafTris:l,strategy:o,onProgress:u,indirect:f}=s,p=i._indirectBuffer,a=i.geometry,y=a.index?a.index.array:null,d=f?Zn:Yn,b=ut(a),g=new Float32Array(6);let h=!1;const x=new Zt;return Yt(n,t,e,x.boundingData,g),w(x,t,e,g),x;function m(A){u&&u(A/b)}function w(A,T,B,P=null,S=0){if(!h&&S>=c&&(h=!0,r&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(a))),B<=l||S>=c)return m(T+B),A.offset=T,A.count=B,A;const M=In(A.boundingData,P,n,T,B,o);if(M.axis===-1)return m(T+B),A.offset=T,A.count=B,A;const U=d(p,y,n,T,B,M);if(U===T||U===T+B)m(T+B),A.offset=T,A.count=B;else{A.splitAxis=M.axis;const _=new Zt,C=T,L=U-T;A.left=_,Yt(n,C,L,_.boundingData,g),w(_,C,L,g,S+1);const E=new Zt,R=U,Z=B-L;A.right=E,Yt(n,R,Z,E.boundingData,g),w(E,R,Z,g,S+1)}return A}}function Gn(i,n){const t=i.geometry;n.indirect&&(i._indirectBuffer=Jn(t,n.useSharedArrayBuffer),qn(t,n.range)&&!n.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),i._indirectBuffer||kn(t,n);const e=n.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,s=Xn(t),c=n.indirect?Mn(t,n.range):Sn(t,n.range);i._roots=c.map(r=>{const l=Qn(i,s,r.offset,r.count,n),o=tn(l),u=new e(dt*o);return Wn(0,l,u),u})}class N{constructor(n,t,e){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new G,this.invMatrix=new G,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new bt),this.alignedSatBounds=new Array(3).fill().map(()=>new bt),this.needsUpdate=!1,n&&this.min.copy(n),t&&this.max.copy(t),e&&this.matrix.copy(e)}set(n,t,e){this.min.copy(n),this.max.copy(t),this.matrix.copy(e),this.needsUpdate=!0}copy(n){this.min.copy(n.min),this.max.copy(n.max),this.matrix.copy(n.matrix),this.needsUpdate=!0}}N.prototype.update=function(){return function(){const n=this.matrix,t=this.min,e=this.max,s=this.points;for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)for(let p=0;p<=1;p++){const a=1*u|2*f|4*p,y=s[a];y.x=u?e.x:t.x,y.y=f?e.y:t.y,y.z=p?e.z:t.z,y.applyMatrix4(n)}const c=this.satBounds,r=this.satAxes,l=s[0];for(let u=0;u<3;u++){const f=r[u],p=c[u],a=1<<u,y=s[a];f.subVectors(l,y),p.setFromPoints(f,s)}const o=this.alignedSatBounds;o[0].setFromPointsField(s,"x"),o[1].setFromPointsField(s,"y"),o[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();N.prototype.intersectsBox=function(){const i=new bt;return function(t){this.needsUpdate&&this.update();const e=t.min,s=t.max,c=this.satBounds,r=this.satAxes,l=this.alignedSatBounds;if(i.min=e.x,i.max=s.x,l[0].isSeparated(i)||(i.min=e.y,i.max=s.y,l[1].isSeparated(i))||(i.min=e.z,i.max=s.z,l[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const u=r[o],f=c[o];if(i.setFromBox(u,t),f.isSeparated(i))return!1}return!0}}();N.prototype.intersectsTriangle=function(){const i=new ft,n=new Array(3),t=new bt,e=new bt,s=new z;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const l=this.satBounds,o=this.satAxes;n[0]=r.a,n[1]=r.b,n[2]=r.c;for(let a=0;a<3;a++){const y=l[a],d=o[a];if(t.setFromPoints(d,n),y.isSeparated(t))return!1}const u=r.satBounds,f=r.satAxes,p=this.points;for(let a=0;a<3;a++){const y=u[a],d=f[a];if(t.setFromPoints(d,p),y.isSeparated(t))return!1}for(let a=0;a<3;a++){const y=o[a];for(let d=0;d<4;d++){const b=f[d];if(s.crossVectors(y,b),t.setFromPoints(s,n),e.setFromPoints(s,p),t.isSeparated(e))return!1}}return!0}}();N.prototype.closestPointToPoint=function(){return function(n,t){return this.needsUpdate&&this.update(),t.copy(n).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),t}}();N.prototype.distanceToPoint=function(){const i=new z;return function(t){return this.closestPointToPoint(t,i),t.distanceTo(i)}}();N.prototype.distanceToBox=function(){const i=["x","y","z"],n=new Array(12).fill().map(()=>new un),t=new Array(12).fill().map(()=>new un),e=new z,s=new z;return function(r,l=0,o=null,u=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||u)&&(r.getCenter(s),this.closestPointToPoint(s,e),r.closestPointToPoint(e,s),o&&o.copy(e),u&&u.copy(s)),0;const f=l*l,p=r.min,a=r.max,y=this.points;let d=1/0;for(let g=0;g<8;g++){const h=y[g];s.copy(h).clamp(p,a);const x=h.distanceToSquared(s);if(x<d&&(d=x,o&&o.copy(h),u&&u.copy(s),x<f))return Math.sqrt(x)}let b=0;for(let g=0;g<3;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){const m=(g+1)%3,w=(g+2)%3,A=h<<m|x<<w,T=1<<g|h<<m|x<<w,B=y[A],P=y[T];n[b].set(B,P);const M=i[g],U=i[m],_=i[w],C=t[b],L=C.start,E=C.end;L[M]=p[M],L[U]=h?p[U]:a[U],L[_]=x?p[_]:a[U],E[M]=a[M],E[U]=h?p[U]:a[U],E[_]=x?p[_]:a[U],b++}for(let g=0;g<=1;g++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){s.x=g?a.x:p.x,s.y=h?a.y:p.y,s.z=x?a.z:p.z,this.closestPointToPoint(s,e);const m=s.distanceToSquared(e);if(m<d&&(d=m,o&&o.copy(e),u&&u.copy(s),m<f))return Math.sqrt(m)}for(let g=0;g<12;g++){const h=n[g];for(let x=0;x<12;x++){const m=t[x];zn(h,m,e,s);const w=e.distanceToSquared(s);if(w<d&&(d=w,o&&o.copy(e),u&&u.copy(s),w<f))return Math.sqrt(w)}}return Math.sqrt(d)}}();class fn{constructor(n){this._getNewPrimitive=n,this._primitives=[]}getPrimitive(){const n=this._primitives;return n.length===0?this._getNewPrimitive():n.pop()}releasePrimitive(n){this._primitives.push(n)}}class On extends fn{constructor(){super(()=>new ft)}}const H=new On;class ti{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const n=[];let t=null;this.setBuffer=e=>{t&&n.push(t),t=e,this.float32Array=new Float32Array(e),this.uint16Array=new Uint16Array(e),this.uint32Array=new Uint32Array(e)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,n.length!==0&&this.setBuffer(n.pop())}}}const D=new ti;let J,at;const O=[],Ct=new fn(()=>new j);function ni(i,n,t,e,s,c){J=Ct.getPrimitive(),at=Ct.getPrimitive(),O.push(J,at),D.setBuffer(i._roots[n]);const r=en(0,i.geometry,t,e,s,c);D.clearBuffer(),Ct.releasePrimitive(J),Ct.releasePrimitive(at),O.pop(),O.pop();const l=O.length;return l>0&&(at=O[l-1],J=O[l-2]),r}function en(i,n,t,e,s=null,c=0,r=0){const{float32Array:l,uint16Array:o,uint32Array:u}=D;let f=i*2;if(V(f,o)){const a=$(i,u),y=k(f,o);return F(i,l,J),e(a,y,!1,r,c+i,J)}else{let M=function(_){const{uint16Array:C,uint32Array:L}=D;let E=_*2;for(;!V(E,C);)_=q(_),E=_*2;return $(_,L)},U=function(_){const{uint16Array:C,uint32Array:L}=D;let E=_*2;for(;!V(E,C);)_=X(_,L),E=_*2;return $(_,L)+k(E,C)};const a=q(i),y=X(i,u);let d=a,b=y,g,h,x,m;if(s&&(x=J,m=at,F(d,l,x),F(b,l,m),g=s(x),h=s(m),h<g)){d=y,b=a;const _=g;g=h,h=_,x=m}x||(x=J,F(d,l,x));const w=V(d*2,o),A=t(x,w,g,r+1,c+d);let T;if(A===yn){const _=M(d),L=U(d)-_;T=e(_,L,!0,r+1,c+d,x)}else T=A&&en(d,n,t,e,s,c,r+1);if(T)return!0;m=at,F(b,l,m);const B=V(b*2,o),P=t(m,B,h,r+1,c+b);let S;if(P===yn){const _=M(b),L=U(b)-_;S=e(_,L,!0,r+1,c+b,m)}else S=P&&en(b,n,t,e,s,c,r+1);return!!S}}const At=new z,Kt=new z;function ii(i,n,t={},e=0,s=1/0){const c=e*e,r=s*s;let l=1/0,o=null;if(i.shapecast({boundsTraverseOrder:f=>(At.copy(n).clamp(f.min,f.max),At.distanceToSquared(n)),intersectsBounds:(f,p,a)=>a<l&&a<r,intersectsTriangle:(f,p)=>{f.closestPointToPoint(n,At);const a=n.distanceToSquared(At);return a<l&&(Kt.copy(At),l=a,o=p),a<c}}),l===1/0)return null;const u=Math.sqrt(l);return t.point?t.point.copy(Kt):t.point=Kt.clone(),t.distance=u,t.faceIndex=o,t}const tt=new z,nt=new z,it=new z,Ut=new _t,Lt=new _t,Et=new _t,gn=new z,wn=new z,Bn=new z,zt=new z;function ei(i,n,t,e,s,c,r,l){let o;if(c===Dn?o=i.intersectTriangle(e,t,n,!0,s):o=i.intersectTriangle(n,t,e,c!==Fn,s),o===null)return null;const u=i.origin.distanceTo(s);return u<r||u>l?null:{distance:u,point:s.clone()}}function si(i,n,t,e,s,c,r,l,o,u,f){tt.fromBufferAttribute(n,c),nt.fromBufferAttribute(n,r),it.fromBufferAttribute(n,l);const p=ei(i,tt,nt,it,zt,o,u,f);if(p){e&&(Ut.fromBufferAttribute(e,c),Lt.fromBufferAttribute(e,r),Et.fromBufferAttribute(e,l),p.uv=Pt.getInterpolation(zt,tt,nt,it,Ut,Lt,Et,new _t)),s&&(Ut.fromBufferAttribute(s,c),Lt.fromBufferAttribute(s,r),Et.fromBufferAttribute(s,l),p.uv1=Pt.getInterpolation(zt,tt,nt,it,Ut,Lt,Et,new _t)),t&&(gn.fromBufferAttribute(t,c),wn.fromBufferAttribute(t,r),Bn.fromBufferAttribute(t,l),p.normal=Pt.getInterpolation(zt,tt,nt,it,gn,wn,Bn,new z),p.normal.dot(i.direction)>0&&p.normal.multiplyScalar(-1));const a={a:c,b:r,c:l,normal:new z,materialIndex:0};Pt.getNormal(tt,nt,it,a.normal),p.face=a,p.faceIndex=c}return p}function Ht(i,n,t,e,s,c,r){const l=e*3;let o=l+0,u=l+1,f=l+2;const p=i.index;i.index&&(o=p.getX(o),u=p.getX(u),f=p.getX(f));const{position:a,normal:y,uv:d,uv1:b}=i.attributes,g=si(t,a,y,d,b,o,u,f,n,c,r);return g?(g.faceIndex=e,s&&s.push(g),g):null}function v(i,n,t,e){const s=i.a,c=i.b,r=i.c;let l=n,o=n+1,u=n+2;t&&(l=t.getX(l),o=t.getX(o),u=t.getX(u)),s.x=e.getX(l),s.y=e.getY(l),s.z=e.getZ(l),c.x=e.getX(o),c.y=e.getY(o),c.z=e.getZ(o),r.x=e.getX(u),r.y=e.getY(u),r.z=e.getZ(u)}function ri(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:u}=i;for(let f=e,p=e+s;f<p;f++)Ht(o,n,t,f,c,r,l)}function oi(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let u=1/0,f=null;for(let p=e,a=e+s;p<a;p++){let y;y=Ht(l,n,t,p,null,c,r),y&&y.distance<u&&(f=y,u=y.distance)}return f}function ci(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,u=l.attributes.position;for(let f=i,p=n+i;f<p;f++){let a;if(a=f,v(r,a*3,o,u),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function li(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,u=0;const f=i._roots;for(let a=0,y=f.length;a<y;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),p(0,u),u+=c.byteLength;function p(a,y,d=!1){const b=a*2;if(l[b+15]===Xt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=3*h,M=3*(h+x);S<M;S++){let U=e[S];const _=s.getX(U),C=s.getY(U),L=s.getZ(U);_<m&&(m=_),_>T&&(T=_),C<w&&(w=C),C>B&&(B=C),L<A&&(A=L),L>P&&(P=L)}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+y,w=x+y;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=p(h,y,A));let U=!1;S&&(U=p(x,y,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,R=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=R<pt?R:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function Q(i,n,t,e,s){let c,r,l,o,u,f;const p=1/t.direction.x,a=1/t.direction.y,y=1/t.direction.z,d=t.origin.x,b=t.origin.y,g=t.origin.z;let h=n[i],x=n[i+3],m=n[i+1],w=n[i+3+1],A=n[i+2],T=n[i+3+2];return p>=0?(c=(h-d)*p,r=(x-d)*p):(c=(x-d)*p,r=(h-d)*p),a>=0?(l=(m-b)*a,o=(w-b)*a):(l=(w-b)*a,o=(m-b)*a),c>o||l>r||((l>c||isNaN(c))&&(c=l),(o<r||isNaN(r))&&(r=o),y>=0?(u=(A-g)*y,f=(T-g)*y):(u=(T-g)*y,f=(A-g)*y),c>f||u>r)?!1:((u>c||c!==c)&&(c=u),(f<r||r!==r)&&(r=f),c<=s&&r>=e)}function ai(i,n,t,e,s,c,r,l){const{geometry:o,_indirectBuffer:u}=i;for(let f=e,p=e+s;f<p;f++){let a=u?u[f]:f;Ht(o,n,t,a,c,r,l)}}function fi(i,n,t,e,s,c,r){const{geometry:l,_indirectBuffer:o}=i;let u=1/0,f=null;for(let p=e,a=e+s;p<a;p++){let y;y=Ht(l,n,t,o?o[p]:p,null,c,r),y&&y.distance<u&&(f=y,u=y.distance)}return f}function ui(i,n,t,e,s,c,r){const{geometry:l}=t,{index:o}=l,u=l.attributes.position;for(let f=i,p=n+i;f<p;f++){let a;if(a=t.resolveTriangleIndex(f),v(r,a*3,o,u),r.needsUpdate=!0,e(r,a,s,c))return!0}return!1}function pi(i,n,t,e,s,c,r){D.setBuffer(i._roots[n]),sn(0,i,t,e,s,c,r),D.clearBuffer()}function sn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:u}=D,f=i*2;if(V(f,o)){const a=$(i,u),y=k(f,o);ri(n,t,e,a,y,s,c,r)}else{const a=q(i);Q(a,l,e,c,r)&&sn(a,n,t,e,s,c,r);const y=X(i,u);Q(y,l,e,c,r)&&sn(y,n,t,e,s,c,r)}}const yi=["x","y","z"];function xi(i,n,t,e,s,c){D.setBuffer(i._roots[n]);const r=rn(0,i,t,e,s,c);return D.clearBuffer(),r}function rn(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=D;let u=i*2;if(V(u,l)){const p=$(i,o),a=k(u,l);return oi(n,t,e,p,a,s,c)}else{const p=Cn(i,o),a=yi[p],d=e.direction[a]>=0;let b,g;d?(b=q(i),g=X(i,o)):(b=X(i,o),g=q(i));const x=Q(b,r,e,s,c)?rn(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+p]:A>=r[g+p+3])return x}const w=Q(g,r,e,s,c)?rn(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const Dt=new j,et=new ft,st=new ft,mt=new G,dn=new N,Ft=new N;function Ai(i,n,t,e){D.setBuffer(i._roots[n]);const s=on(0,i,t,e);return D.clearBuffer(),s}function on(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=D;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),dn.set(t.boundingBox.min,t.boundingBox.max,e),s=dn),V(o,r)){const f=n.geometry,p=f.index,a=f.attributes.position,y=t.index,d=t.attributes.position,b=$(i,l),g=k(o,r);if(mt.copy(e).invert(),t.boundsTree)return F(i,c,Ft),Ft.matrix.copy(mt),Ft.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Ft.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b*3,w=(g+b)*3;m<w;m+=3)if(v(st,m,p,a),st.needsUpdate=!0,x.intersectsTriangle(st))return!0;return!1}});for(let h=b*3,x=(g+b)*3;h<x;h+=3){v(et,h,p,a),et.a.applyMatrix4(mt),et.b.applyMatrix4(mt),et.c.applyMatrix4(mt),et.needsUpdate=!0;for(let m=0,w=y.count;m<w;m+=3)if(v(st,m,y,d),st.needsUpdate=!0,et.intersectsTriangle(st))return!0}}else{const f=i+8,p=l[i+6];return F(f,c,Dt),!!(s.intersectsBox(Dt)&&on(f,n,t,e,s)||(F(p,c,Dt),s.intersectsBox(Dt)&&on(p,n,t,e,s)))}}const Rt=new G,Wt=new N,ht=new N,mi=new z,hi=new z,gi=new z,wi=new z;function Bi(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Wt.set(n.boundingBox.min,n.boundingBox.max,t),Wt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,u=l.index,f=n.attributes.position,p=n.index,a=H.getPrimitive(),y=H.getPrimitive();let d=mi,b=hi,g=null,h=null;s&&(g=gi,h=wi);let x=1/0,m=null,w=null;return Rt.copy(t).invert(),ht.matrix.copy(Rt),i.shapecast({boundsTraverseOrder:A=>Wt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(ht.min.copy(A.min),ht.max.copy(A.max),ht.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree)return n.boundsTree.shapecast({boundsTraverseOrder:P=>ht.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){v(y,3*M,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let _=A,C=A+T;_<C;_++){v(a,3*_,u,o),a.needsUpdate=!0;const L=a.distanceToTriangle(y,d,g);if(L<x&&(b.copy(d),h&&h.copy(g),x=L,m=_,w=M),L<c)return!0}}}});{const B=ut(n);for(let P=0,S=B;P<S;P++){v(y,3*P,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){v(a,3*M,u,o),a.needsUpdate=!0;const _=a.distanceToTriangle(y,d,g);if(_<x&&(b.copy(d),h&&h.copy(g),x=_,m=M,w=P),_<c)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4(Rt),b.applyMatrix4(Rt),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function di(i,n=null){n&&Array.isArray(n)&&(n=new Set(n));const t=i.geometry,e=t.index?t.index.array:null,s=t.attributes.position;let c,r,l,o,u=0;const f=i._roots;for(let a=0,y=f.length;a<y;a++)c=f[a],r=new Uint32Array(c),l=new Uint16Array(c),o=new Float32Array(c),p(0,u),u+=c.byteLength;function p(a,y,d=!1){const b=a*2;if(l[b+15]===Xt){const h=r[a+6],x=l[b+14];let m=1/0,w=1/0,A=1/0,T=-1/0,B=-1/0,P=-1/0;for(let S=h,M=h+x;S<M;S++){const U=3*i.resolveTriangleIndex(S);for(let _=0;_<3;_++){let C=U+_;C=e?e[C]:C;const L=s.getX(C),E=s.getY(C),R=s.getZ(C);L<m&&(m=L),L>T&&(T=L),E<w&&(w=E),E>B&&(B=E),R<A&&(A=R),R>P&&(P=R)}}return o[a+0]!==m||o[a+1]!==w||o[a+2]!==A||o[a+3]!==T||o[a+4]!==B||o[a+5]!==P?(o[a+0]=m,o[a+1]=w,o[a+2]=A,o[a+3]=T,o[a+4]=B,o[a+5]=P,!0):!1}else{const h=a+8,x=r[a+6],m=h+y,w=x+y;let A=d,T=!1,B=!1;n?A||(T=n.has(m),B=n.has(w),A=!T&&!B):(T=!0,B=!0);const P=A||T,S=A||B;let M=!1;P&&(M=p(h,y,A));let U=!1;S&&(U=p(x,y,A));const _=M||U;if(_)for(let C=0;C<3;C++){const L=h+C,E=x+C,R=o[L],Z=o[L+3],pt=o[E],yt=o[E+3];o[a+C]=R<pt?R:pt,o[a+C+3]=Z>yt?Z:yt}return _}}}function Ti(i,n,t,e,s,c,r){D.setBuffer(i._roots[n]),cn(0,i,t,e,s,c,r),D.clearBuffer()}function cn(i,n,t,e,s,c,r){const{float32Array:l,uint16Array:o,uint32Array:u}=D,f=i*2;if(V(f,o)){const a=$(i,u),y=k(f,o);ai(n,t,e,a,y,s,c,r)}else{const a=q(i);Q(a,l,e,c,r)&&cn(a,n,t,e,s,c,r);const y=X(i,u);Q(y,l,e,c,r)&&cn(y,n,t,e,s,c,r)}}const bi=["x","y","z"];function _i(i,n,t,e,s,c){D.setBuffer(i._roots[n]);const r=ln(0,i,t,e,s,c);return D.clearBuffer(),r}function ln(i,n,t,e,s,c){const{float32Array:r,uint16Array:l,uint32Array:o}=D;let u=i*2;if(V(u,l)){const p=$(i,o),a=k(u,l);return fi(n,t,e,p,a,s,c)}else{const p=Cn(i,o),a=bi[p],d=e.direction[a]>=0;let b,g;d?(b=q(i),g=X(i,o)):(b=X(i,o),g=q(i));const x=Q(b,r,e,s,c)?ln(b,n,t,e,s,c):null;if(x){const A=x.point[a];if(d?A<=r[g+p]:A>=r[g+p+3])return x}const w=Q(g,r,e,s,c)?ln(g,n,t,e,s,c):null;return x&&w?x.distance<=w.distance?x:w:x||w||null}}const vt=new j,rt=new ft,ot=new ft,gt=new G,Tn=new N,Nt=new N;function Pi(i,n,t,e){D.setBuffer(i._roots[n]);const s=an(0,i,t,e);return D.clearBuffer(),s}function an(i,n,t,e,s=null){const{float32Array:c,uint16Array:r,uint32Array:l}=D;let o=i*2;if(s===null&&(t.boundingBox||t.computeBoundingBox(),Tn.set(t.boundingBox.min,t.boundingBox.max,e),s=Tn),V(o,r)){const f=n.geometry,p=f.index,a=f.attributes.position,y=t.index,d=t.attributes.position,b=$(i,l),g=k(o,r);if(gt.copy(e).invert(),t.boundsTree)return F(i,c,Nt),Nt.matrix.copy(gt),Nt.needsUpdate=!0,t.boundsTree.shapecast({intersectsBounds:x=>Nt.intersectsBox(x),intersectsTriangle:x=>{x.a.applyMatrix4(e),x.b.applyMatrix4(e),x.c.applyMatrix4(e),x.needsUpdate=!0;for(let m=b,w=g+b;m<w;m++)if(v(ot,3*n.resolveTriangleIndex(m),p,a),ot.needsUpdate=!0,x.intersectsTriangle(ot))return!0;return!1}});for(let h=b,x=g+b;h<x;h++){const m=n.resolveTriangleIndex(h);v(rt,3*m,p,a),rt.a.applyMatrix4(gt),rt.b.applyMatrix4(gt),rt.c.applyMatrix4(gt),rt.needsUpdate=!0;for(let w=0,A=y.count;w<A;w+=3)if(v(ot,w,y,d),ot.needsUpdate=!0,rt.intersectsTriangle(ot))return!0}}else{const f=i+8,p=l[i+6];return F(f,c,vt),!!(s.intersectsBox(vt)&&an(f,n,t,e,s)||(F(p,c,vt),s.intersectsBox(vt)&&an(p,n,t,e,s)))}}const Vt=new G,Jt=new N,wt=new N,Mi=new z,Si=new z,Ci=new z,Ui=new z;function Li(i,n,t,e={},s={},c=0,r=1/0){n.boundingBox||n.computeBoundingBox(),Jt.set(n.boundingBox.min,n.boundingBox.max,t),Jt.needsUpdate=!0;const l=i.geometry,o=l.attributes.position,u=l.index,f=n.attributes.position,p=n.index,a=H.getPrimitive(),y=H.getPrimitive();let d=Mi,b=Si,g=null,h=null;s&&(g=Ci,h=Ui);let x=1/0,m=null,w=null;return Vt.copy(t).invert(),wt.matrix.copy(Vt),i.shapecast({boundsTraverseOrder:A=>Jt.distanceToBox(A),intersectsBounds:(A,T,B)=>B<x&&B<r?(T&&(wt.min.copy(A.min),wt.max.copy(A.max),wt.needsUpdate=!0),!0):!1,intersectsRange:(A,T)=>{if(n.boundsTree){const B=n.boundsTree;return B.shapecast({boundsTraverseOrder:P=>wt.distanceToBox(P),intersectsBounds:(P,S,M)=>M<x&&M<r,intersectsRange:(P,S)=>{for(let M=P,U=P+S;M<U;M++){const _=B.resolveTriangleIndex(M);v(y,3*_,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let C=A,L=A+T;C<L;C++){const E=i.resolveTriangleIndex(C);v(a,3*E,u,o),a.needsUpdate=!0;const R=a.distanceToTriangle(y,d,g);if(R<x&&(b.copy(d),h&&h.copy(g),x=R,m=C,w=M),R<c)return!0}}}})}else{const B=ut(n);for(let P=0,S=B;P<S;P++){v(y,3*P,p,f),y.a.applyMatrix4(t),y.b.applyMatrix4(t),y.c.applyMatrix4(t),y.needsUpdate=!0;for(let M=A,U=A+T;M<U;M++){const _=i.resolveTriangleIndex(M);v(a,3*_,u,o),a.needsUpdate=!0;const C=a.distanceToTriangle(y,d,g);if(C<x&&(b.copy(d),h&&h.copy(g),x=C,m=M,w=P),C<c)return!0}}}}}),H.releasePrimitive(a),H.releasePrimitive(y),x===1/0?null:(e.point?e.point.copy(b):e.point=b.clone(),e.distance=x,e.faceIndex=m,s&&(s.point?s.point.copy(h):s.point=h.clone(),s.point.applyMatrix4(Vt),b.applyMatrix4(Vt),s.distance=b.sub(s.point).length(),s.faceIndex=w),e)}function Ei(){return typeof SharedArrayBuffer<"u"}function Vi(i,n){if(i===null)return i;if(i.buffer){const t=i.buffer;if(t.constructor===n)return i;const e=i.constructor,s=new e(new n(t.byteLength));return s.set(i),s}else{if(i.constructor===n)return i;const t=new n(i.byteLength);return new Uint8Array(t).set(new Uint8Array(i)),t}}const Tt=new D.constructor,qt=new D.constructor,W=new fn(()=>new j),ct=new j,lt=new j,Qt=new j,Gt=new j;let Ot=!1;function zi(i,n,t,e){if(Ot)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ot=!0;const s=i._roots,c=n._roots;let r,l=0,o=0;const u=new G().copy(t).invert();for(let f=0,p=s.length;f<p;f++){Tt.setBuffer(s[f]),o=0;const a=W.getPrimitive();F(0,Tt.float32Array,a),a.applyMatrix4(u);for(let y=0,d=c.length;y<d&&(qt.setBuffer(c[y]),r=I(0,0,t,u,e,l,o,0,0,a),qt.clearBuffer(),o+=c[y].length,!r);y++);if(W.releasePrimitive(a),Tt.clearBuffer(),l+=s[f].length,r)break}return Ot=!1,r}function I(i,n,t,e,s,c=0,r=0,l=0,o=0,u=null,f=!1){let p,a;f?(p=qt,a=Tt):(p=Tt,a=qt);const y=p.float32Array,d=p.uint32Array,b=p.uint16Array,g=a.float32Array,h=a.uint32Array,x=a.uint16Array,m=i*2,w=n*2,A=V(m,b),T=V(w,x);let B=!1;if(T&&A)f?B=s($(n,h),k(n*2,x),$(i,d),k(i*2,b),o,r+n,l,c+i):B=s($(i,d),k(i*2,b),$(n,h),k(n*2,x),l,c+i,o,r+n);else if(T){const P=W.getPrimitive();F(n,g,P),P.applyMatrix4(t);const S=q(i),M=X(i,d);F(S,y,ct),F(M,y,lt);const U=P.intersectsBox(ct),_=P.intersectsBox(lt);B=U&&I(n,S,e,t,s,r,c,o,l+1,P,!f)||_&&I(n,M,e,t,s,r,c,o,l+1,P,!f),W.releasePrimitive(P)}else{const P=q(n),S=X(n,h);F(P,g,Qt),F(S,g,Gt);const M=u.intersectsBox(Qt),U=u.intersectsBox(Gt);if(M&&U)B=I(i,P,t,e,s,c,r,l,o+1,u,f)||I(i,S,t,e,s,c,r,l,o+1,u,f);else if(M)if(A)B=I(i,P,t,e,s,c,r,l,o+1,u,f);else{const _=W.getPrimitive();_.copy(Qt).applyMatrix4(t);const C=q(i),L=X(i,d);F(C,y,ct),F(L,y,lt);const E=_.intersectsBox(ct),R=_.intersectsBox(lt);B=E&&I(P,C,e,t,s,r,c,o,l+1,_,!f)||R&&I(P,L,e,t,s,r,c,o,l+1,_,!f),W.releasePrimitive(_)}else if(U)if(A)B=I(i,S,t,e,s,c,r,l,o+1,u,f);else{const _=W.getPrimitive();_.copy(Gt).applyMatrix4(t);const C=q(i),L=X(i,d);F(C,y,ct),F(L,y,lt);const E=_.intersectsBox(ct),R=_.intersectsBox(lt);B=E&&I(S,C,e,t,s,r,c,o,l+1,_,!f)||R&&I(S,L,e,t,s,r,c,o,l+1,_,!f),W.releasePrimitive(_)}}return B}const $t=new N,bn=new j,Di={strategy:Pn,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class En{static serialize(n,t={}){t={cloneBuffers:!0,...t};const e=n.geometry,s=n._roots,c=n._indirectBuffer,r=e.getIndex();let l;return t.cloneBuffers?l={roots:s.map(o=>o.slice()),index:r?r.array.slice():null,indirectBuffer:c?c.slice():null}:l={roots:s,index:r?r.array:null,indirectBuffer:c},l}static deserialize(n,t,e={}){e={setIndex:!0,indirect:!!n.indirectBuffer,...e};const{index:s,roots:c,indirectBuffer:r}=n,l=new En(t,{...e,[jt]:!0});if(l._roots=c,l._indirectBuffer=r||null,e.setIndex){const o=t.getIndex();if(o===null){const u=new _n(n.index,1,!1);t.setIndex(u)}else o.array!==s&&(o.array.set(s),o.needsUpdate=!0)}return l}get indirect(){return!!this._indirectBuffer}constructor(n,t={}){if(n.isBufferGeometry){if(n.index&&n.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t=Object.assign({...Di,[jt]:!1},t),t.useSharedArrayBuffer&&!Ei())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=n,this._roots=null,this._indirectBuffer=null,t[jt]||(Gn(this,t),!n.boundingBox&&t.setBoundingBox&&(n.boundingBox=this.getBoundingBox(new j))),this.resolveTriangleIndex=t.indirect?e=>this._indirectBuffer[e]:e=>e}refit(n=null){return(this.indirect?di:li)(this,n)}traverse(n,t=0){const e=this._roots[t],s=new Uint32Array(e),c=new Uint16Array(e);r(0);function r(l,o=0){const u=l*2,f=c[u+15]===Xt;if(f){const p=s[l+6],a=c[u+14];n(o,f,new Float32Array(e,l*4,6),p,a)}else{const p=l+dt/4,a=s[l+6],y=s[l+7];n(o,f,new Float32Array(e,l*4,6),y)||(r(p,o+1),r(a,o+1))}}}raycast(n,t=pn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=[],o=t.isMaterial,u=Array.isArray(t),f=r.groups,p=o?t.side:t,a=this.indirect?Ti:pi;for(let y=0,d=c.length;y<d;y++){const b=u?t[f[y].materialIndex].side:p,g=l.length;if(a(this,y,b,n,l,e,s),u){const h=f[y].materialIndex;for(let x=g,m=l.length;x<m;x++)l[x].face.materialIndex=h}}return l}raycastFirst(n,t=pn,e=0,s=1/0){const c=this._roots,r=this.geometry,l=t.isMaterial,o=Array.isArray(t);let u=null;const f=r.groups,p=l?t.side:t,a=this.indirect?_i:xi;for(let y=0,d=c.length;y<d;y++){const b=o?t[f[y].materialIndex].side:p,g=a(this,y,b,n,e,s);g!=null&&(u==null||g.distance<u.distance)&&(u=g,o&&(g.face.materialIndex=f[y].materialIndex))}return u}intersectsGeometry(n,t){let e=!1;const s=this._roots,c=this.indirect?Pi:Ai;for(let r=0,l=s.length;r<l&&(e=c(this,r,n,t),!e);r++);return e}shapecast(n){const t=H.getPrimitive(),e=this.indirect?ui:ci;let{boundsTraverseOrder:s,intersectsBounds:c,intersectsRange:r,intersectsTriangle:l}=n;if(r&&l){const p=r;r=(a,y,d,b,g)=>p(a,y,d,b,g)?!0:e(a,y,this,l,d,b,t)}else r||(l?r=(p,a,y,d)=>e(p,a,this,l,y,d,t):r=(p,a,y)=>y);let o=!1,u=0;const f=this._roots;for(let p=0,a=f.length;p<a;p++){const y=f[p];if(o=ni(this,p,c,r,s,u),o)break;u+=y.byteLength}return H.releasePrimitive(t),o}bvhcast(n,t,e){let{intersectsRanges:s,intersectsTriangles:c}=e;const r=H.getPrimitive(),l=this.geometry.index,o=this.geometry.attributes.position,u=this.indirect?d=>{const b=this.resolveTriangleIndex(d);v(r,b*3,l,o)}:d=>{v(r,d*3,l,o)},f=H.getPrimitive(),p=n.geometry.index,a=n.geometry.attributes.position,y=n.indirect?d=>{const b=n.resolveTriangleIndex(d);v(f,b*3,p,a)}:d=>{v(f,d*3,p,a)};if(c){const d=(b,g,h,x,m,w,A,T)=>{for(let B=h,P=h+x;B<P;B++){y(B),f.a.applyMatrix4(t),f.b.applyMatrix4(t),f.c.applyMatrix4(t),f.needsUpdate=!0;for(let S=b,M=b+g;S<M;S++)if(u(S),r.needsUpdate=!0,c(r,f,S,B,m,w,A,T))return!0}return!1};if(s){const b=s;s=function(g,h,x,m,w,A,T,B){return b(g,h,x,m,w,A,T,B)?!0:d(g,h,x,m,w,A,T,B)}}else s=d}return zi(this,n,t,s)}intersectsBox(n,t){return $t.set(n.min,n.max,t),$t.needsUpdate=!0,this.shapecast({intersectsBounds:e=>$t.intersectsBox(e),intersectsTriangle:e=>$t.intersectsTriangle(e)})}intersectsSphere(n){return this.shapecast({intersectsBounds:t=>n.intersectsBox(t),intersectsTriangle:t=>t.intersectsSphere(n)})}closestPointToGeometry(n,t,e={},s={},c=0,r=1/0){return(this.indirect?Li:Bi)(this,n,t,e,s,c,r)}closestPointToPoint(n,t={},e=0,s=1/0){return ii(this,n,t,e,s)}getBoundingBox(n){return n.makeEmpty(),this._roots.forEach(e=>{F(0,new Float32Array(e),bn),n.union(bn)}),n}}export{Rn as A,dt as B,Pn as C,vi as I,En as M,Ri as N,$ as O,X as R,vn as S,It as T,yn as a,Vn as b,Vi as c,V as d,kn as e,k as f,$n as g,Cn as h,Ei as i,Ni as j,xn as k,F as l};
