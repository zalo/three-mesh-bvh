import{M as B,g as I,v as x,aO as S,z as _,V as R,j as v}from"./ExtendedTriangle-Chm2bbkR.js";import{M as y}from"./MeshBVH-CPVAl5W3.js";function b(e,t,o){return e===null?null:(e.point.applyMatrix4(t.matrixWorld),e.distance=e.point.distanceTo(o.ray.origin),e.object=t,e)}const W=parseInt(S)>=166,g=new _,p=new R,w=new v,F=B.prototype.raycast,V=I.prototype.raycast,T=new R,s=new B,m=[];function C(e,t){this.isBatchedMesh?A.call(this,e,t):O.call(this,e,t)}function A(e,t){if(this.boundsTrees){const o=this.boundsTrees,n=this._drawInfo,r=this._drawRanges,i=this.matrixWorld;s.material=this.material,s.geometry=this.geometry;const l=s.geometry.boundsTree,h=s.geometry.drawRange;s.geometry.boundingSphere===null&&(s.geometry.boundingSphere=new x);for(let a=0,u=n.length;a<u;a++){if(!n[a].visible||!n[a].active)continue;const d=n[a].geometryIndex;if(s.geometry.boundsTree=o[d],this.getMatrixAt(a,s.matrixWorld).premultiply(i),!s.geometry.boundsTree){this.getBoundingBoxAt(d,s.geometry.boundingBox),this.getBoundingSphereAt(d,s.geometry.boundingSphere);const c=r[d];s.geometry.setDrawRange(c.start,c.count)}s.raycast(e,m);for(let c=0,M=m.length;c<M;c++){const f=m[c];f.object=this,f.batchId=a,t.push(f)}m.length=0}s.geometry.boundsTree=l,s.geometry.drawRange=h,s.material=null,s.geometry=null}else V.call(this,e,t)}function O(e,t){if(this.geometry.boundsTree){if(this.material===void 0)return;w.copy(this.matrixWorld).invert(),g.copy(e.ray).applyMatrix4(w),T.setFromMatrixScale(this.matrixWorld),p.copy(g.direction).multiply(T);const o=p.length(),n=e.near/o,r=e.far/o,i=this.geometry.boundsTree;if(e.firstHitOnly===!0){const l=b(i.raycastFirst(g,this.material,n,r),this,e);l&&t.push(l)}else{const l=i.raycast(g,this.material,n,r);for(let h=0,a=l.length;h<a;h++){const u=b(l[h],this,e);u&&t.push(u)}}}else F.call(this,e,t)}function D(e={}){return this.boundsTree=new y(this,e),this.boundsTree}function H(){this.boundsTree=null}function N(e=-1,t={}){if(!W)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");t.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),t={...t,indirect:!1,range:null};const o=this._drawRanges,n=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(n).fill(null));const r=this.boundsTrees;for(;r.length<n;)r.push(null);if(e<0){for(let i=0;i<n;i++)t.range=o[i],r[i]=new y(this.geometry,t);return r}else return e<o.length&&(t.range=o[e],r[e]=new y(this.geometry,t)),r[e]||null}function q(e=-1){e<0?this.boundsTrees.fill(null):e<this.boundsTree.length&&(this.boundsTrees[e]=null)}export{C as a,N as b,D as c,H as d,q as e};
